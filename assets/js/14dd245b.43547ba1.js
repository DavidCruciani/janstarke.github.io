"use strict";(self.webpackChunkjanstarke_blog=self.webpackChunkjanstarke_blog||[]).push([[5795],{2188:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>d});var s=n(4848),r=n(8453);const i={layout:"post",title:"$MFT file parser improved",date:new Date("2021-10-17T00:00:00.000Z"),categories:"rust forensics",authors:["jasa"]},o="What's missing?",a={permalink:"/blog/2021/10/17/mft2bodyfile2",source:"@site/blog/2021-10-17-mft2bodyfile2.mdx",title:"$MFT file parser improved",description:"I added some improvements to mft2bodyfile (https",date:"2021-10-17T00:00:00.000Z",tags:[],readingTime:.855,hasTruncateMarker:!1,authors:[{name:"Jan Starke",title:"Senior Forensic Analyst",url:"https://github.com/janstarke",imageURL:"https://github.com/janstarke.png",key:"jasa"}],frontMatter:{layout:"post",title:"$MFT file parser improved",date:"2021-10-17T00:00:00.000Z",categories:"rust forensics",authors:["jasa"]},unlisted:!1,prevItem:{title:"Forensic analysis of deleted `$MFT` entries",permalink:"/blog/2021/10/22/mft_entry_sequence"},nextItem:{title:"$MFT file parser finalized",permalink:"/blog/2021/05/16/mft2bodyfile"}},l={authorsImageUrls:[void 0]},d=[];function c(e){const t={a:"a",code:"code",em:"em",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["I added some improvements to ",(0,s.jsx)(t.code,{children:"mft2bodyfile"})," (",(0,s.jsx)(t.a,{href:"https://github.com/janstarke/mft2bodyfile",children:"https://github.com/janstarke/mft2bodyfile"}),") and released version ",(0,s.jsx)(t.em,{children:"0.5.0"}),". Mainly, the following things have changed:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["I fixed the problem with nonresident attributes: ",(0,s.jsx)(t.code,{children:"mft2bodyfile"})," reads all (really: ",(0,s.jsx)(t.em,{children:"all"}),") MFT entries and tries to correlate them. This is possible, because there is a bidirectional relationship between the base entry and the nonbase entries. Until now, I started with the base entry and tried to find the corresponding nonbase entries, which failed if the ",(0,s.jsx)(t.code,{children:"$ATTRIBUTE_LIST"})," was nonresident. Now, I don't try to find the nonbase entries, but instead use the base reference to find the base entry."]}),"\n",(0,s.jsx)(t.li,{children:"The performance has improved a lot."}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Only one thing (at the moment): Sometimes there are nonbase entries which belonged to base entries of deleted files (this can be detected to the sequence numbers of the base reference and the entry at the base position do not match). This is no problem, until we try to read ",(0,s.jsx)(t.code,{children:"$STANDARD_INFORMATION"}),"or ",(0,s.jsx)(t.code,{children:"$FILENAME"}),", which may not be existing anymore. These entries are ignored by ",(0,s.jsx)(t.code,{children:"mft2bodyfile"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(6540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);