"use strict";(self.webpackChunkjanstarke_blog=self.webpackChunkjanstarke_blog||[]).push([[8995],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),f=c(t),d=i,m=f["".concat(s,".").concat(d)]||f[d]||u[d]||o;return t?r.createElement(m,a(a({ref:n},p),{},{components:t})):r.createElement(m,a({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[f]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=t[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8646:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=t(7462),i=(t(7294),t(3905));const o={title:"Userspace tool for (anti-forensically safe) wiping unallocated disk space",date:"2014-02-20",categories:["forensics"],layout:"post"},a=void 0,l={permalink:"/blog/2014/02/20/userspace-tool-for-wiping-unallocated-disk-space",source:"@site/blog/2014-02-20-userspace-tool-for-wiping-unallocated-disk-space.md",title:"Userspace tool for (anti-forensically safe) wiping unallocated disk space",description:"This is just a simple idea and could as easily be rewritten in, e.g., Powershell, Perl, Python or whatever you want.",date:"2014-02-20T00:00:00.000Z",formattedDate:"February 20, 2014",tags:[],readingTime:1.52,hasTruncateMarker:!1,authors:[],frontMatter:{title:"Userspace tool for (anti-forensically safe) wiping unallocated disk space",date:"2014-02-20",categories:["forensics"],layout:"post"},prevItem:{title:"Invalid TCP segments created by macof",permalink:"/blog/2015/02/01/invalid-tcp-segments-created-by-macof"},nextItem:{title:"Solaris: Bufferoverflows in lx-Zones ausnutzen",permalink:"/blog/2014/01/27/solaris-bufferoverflows-in-lx-zones-ausnutzen"}},s={authorsImageUrls:[]},c=[],p={toc:c},f="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(f,(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"This is just a simple idea and could as easily be rewritten in, e.g., Powershell, Perl, Python or whatever you want."),(0,i.kt)("p",null,"I had some problems with compressing the image of a virtual machine, which has been intensively used for a long period of time. I deleted all files inside the VM, but this does not really wipe the data, so that blocks of deleted files must be compressed as well. The simple fix of this is to overwrite unallocated blocks with all zeros."),(0,i.kt)("p",null,"Now, how to accomplish this? This is easy: We create a new file, and fill it with zeros. If we are finished (",(0,i.kt)("inlineCode",{parentName:"p"},"fwrite()"),"failes), we are done and delete the file. That's it."),(0,i.kt)("p",null,"Here is the code. Feel free to reimplement it in the language of your choice:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <signal.h>\n\nconst size_t block_size = 512;\nconst size_t block_count = 1;\nstatic const char* filename = "diskwipe.dat";\nstatic char* block = 0;\nstatic FILE* fp = NULL;\n\nvoid cleanup() {\n    if (block) {\n        free(block);\n    }\n\n    if (fp != NULL) {\n        fflush(fp);\n        fclose(fp);\n        fp = NULL;\n    }\n\n    if (0 != _unlink(filename)) {\n        perror("Unable to delete diskwipe.dat: ");\n    }\n}\n\nvoid finish(int res) {\n    cleanup();\n    exit(res);\n}\n\nvoid handle_sigint (int sig) {\n    finish(1);\n}\n\nvoid do_wipe() {\n    unsigned long int count = 0;\n    fp = fopen(filename, "wbc");\n    if (fp == NULL) {\n        perror("Unable to open diskwipe.dat: ");\n        finish(1);\n    }\n\n    while (block_count == fwrite(block, block_size, block_count, fp)) {\n        fflush(fp);\n        fprintf(stderr, "\\\\r%lu", ++count);\n    }\n    fclose(fp);\n}\n\nint main(int argc, char* argv[]) {\n    signal(SIGINT, handle_sigint);\n\n    block = (char*) malloc(block_size);\n    memset(block, 0, block_size);\n    \n    do_wipe();\n    finish(0);\n}\n')),(0,i.kt)("p",null,"By the way, this is a very simple way for doing anti forensics:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"do bad stuff"),(0,i.kt)("li",{parentName:"ol"},"delete your files/traces"),(0,i.kt)("li",{parentName:"ol"},"do a userspace wipe using a builtin scripting language, preferably using a one-liner")))}u.isMDXComponent=!0}}]);