"use strict";(self.webpackChunkjanstarke_blog=self.webpackChunkjanstarke_blog||[]).push([[9449],{6495:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(4848),s=n(8453);const a={layout:"post",title:"$MFT file parser finalized",date:new Date("2021-05-16T00:00:00.000Z"),categories:"rust forensics",authors:["jasa"]},o="Why did i start this project?",r={permalink:"/blog/2021/05/16/mft2bodyfile",source:"@site/blog/2021-05-16-mft2bodyfile.mdx",title:"$MFT file parser finalized",description:"After some days of work, I finalized version 0.3.0 of mft2bodyfile (https://github.com/janstarke/mft2bodyfile), which is aimed to be a replacement for analyze_mft.py, which is abandoned.",date:"2021-05-16T00:00:00.000Z",tags:[],readingTime:1.875,hasTruncateMarker:!1,authors:[{name:"Jan Starke",title:"Senior Forensic Analyst",url:"https://github.com/janstarke",imageURL:"https://github.com/janstarke.png",key:"jasa"}],frontMatter:{layout:"post",title:"$MFT file parser finalized",date:"2021-05-16T00:00:00.000Z",categories:"rust forensics",authors:["jasa"]},unlisted:!1,prevItem:{title:"$MFT file parser improved",permalink:"/blog/2021/10/17/mft2bodyfile2"},nextItem:{title:"DoSing TLS endpoints",permalink:"/blog/2021/03/25/DoSing-TLS-endpoints"}},d={authorsImageUrls:[void 0]},l=[{value:"Update: fixed in <em>0.5.0</em>",id:"update-fixed-in-050",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["After some days of work, I finalized version ",(0,i.jsx)(t.em,{children:"0.3.0"})," of ",(0,i.jsx)(t.code,{children:"mft2bodyfile"})," (",(0,i.jsx)(t.a,{href:"https://github.com/janstarke/mft2bodyfile",children:"https://github.com/janstarke/mft2bodyfile"}),"), which is aimed to be a replacement for ",(0,i.jsx)(t.code,{children:"analyze_mft.py"}),", which is abandoned."]}),"\n",(0,i.jsxs)(t.p,{children:["Until now, me and my team used ",(0,i.jsx)(t.code,{children:"analyze_mft.py"})," to extract data from the ",(0,i.jsx)(t.code,{children:"$MFT"}),", when we got triage data from a customer. Unfortunately, ",(0,i.jsx)(t.code,{children:"analyze_mft.py"})," has some disadvantages:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"python2 is required"}),"\n",(0,i.jsxs)(t.li,{children:["either the ",(0,i.jsx)(t.code,{children:"$STANDARD_INFORMATION"})," or the ",(0,i.jsx)(t.code,{children:"$FILE_NAME"})," attribute used to generate the timestamps, bot not both of them at the same time. This always required us to merge both outputs, which is a little bit messy"]}),"\n",(0,i.jsxs)(t.li,{children:["from time to time we had problems parsing the ",(0,i.jsx)(t.code,{children:"$MFT"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["So, at first we started to work on ",(0,i.jsx)(t.code,{children:"analyze_mft.py"})," to fix our complaints, but we soon got stuck when we discovered one additional disadvantage:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If a file has its ",(0,i.jsx)(t.code,{children:"$FILE_NAME"})," attribute not stored in its base entry, but in some nonbase entry which is refered by an ",(0,i.jsx)(t.code,{children:"$ATTRIBUTE_LIST"})," attribute, then this file is not shown in the bodyfile."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['You might think that "non-base MFT entries do not have the ',(0,i.jsx)(t.code,{children:"$FILE_NAME"})," and ",(0,i.jsx)(t.code,{children:"$STANDARD_INFORMATION"}),' attributes in them", as Brian Carrier has stated in his great book. But we found that this does happen. Further investigation showed us that nearly all fast and simple tools have the same problem. So this was the last bit that led us write a tool for our own.']}),"\n",(0,i.jsx)(t.h1,{id:"what-are-the-advantages-of-this-tool",children:"What are the advantages of this tool?"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["way more faster than ",(0,i.jsx)(t.code,{children:"analyze_mft.py"})]}),"\n",(0,i.jsx)(t.li,{children:"all files are displayed, even if they don't have a '$FILENAME' (Really??? Files can have no filename? Yes, they can. See below)"}),"\n"]}),"\n",(0,i.jsx)(t.h1,{id:"what-are-the-limits-of-this-tool",children:"What are the limits of this tool?"}),"\n",(0,i.jsxs)(t.p,{children:["Consider the following situation: You have a file, which has a lot of attributes. The list of attributes is so long, that it cannot be stored in an ",(0,i.jsx)(t.code,{children:"$MFT"})," entry. So, the ",(0,i.jsx)(t.code,{children:"$ATTRIBUTE_LIST"})," attribute is stored as a nonresident attribute, outside the ",(0,i.jsx)(t.code,{children:"$MFT"}),". At the moment, ",(0,i.jsx)(t.code,{children:"mft2bodyfile"})," is not able to find the corresponding ",(0,i.jsx)(t.code,{children:"$MFT"})," entries, and will generate a filename."]}),"\n",(0,i.jsxs)(t.p,{children:["Can we fix this? Yes, we can. If we detect such a situation, we can search the ",(0,i.jsx)(t.code,{children:"$MFT"})," entries which refer to our base entry, and use those to find a ",(0,i.jsx)(t.code,{children:"$FILE_NAME"})," attribute."]}),"\n",(0,i.jsxs)(t.h2,{id:"update-fixed-in-050",children:["Update: fixed in ",(0,i.jsx)(t.em,{children:"0.5.0"})]})]})}function c(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6540);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);