"use strict";(self.webpackChunkjanstarke_blog=self.webpackChunkjanstarke_blog||[]).push([[8158],{5788:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var s=t(5893),r=t(1151);const i={layout:"post",title:"Rust: Iterators are not faster; Anyway, you should use them",date:new Date("2024-06-15T00:00:00.000Z"),categories:"rust",authors:["jasa"]},a=void 0,o={permalink:"/blog/2024/06/15/rust-using-iterators",source:"@site/blog/2024-06-15-rust-using-iterators.mdx",title:"Rust: Iterators are not faster; Anyway, you should use them",description:"Since some time, I'm wondering whether using iterators in Rust has some",date:"2024-06-15T00:00:00.000Z",tags:[],readingTime:5.695,hasTruncateMarker:!1,authors:[{name:"Jan Starke",title:"Senior Forensic Analyst",url:"https://github.com/janstarke",imageURL:"https://github.com/janstarke.png",key:"jasa"}],frontMatter:{layout:"post",title:"Rust: Iterators are not faster; Anyway, you should use them",date:"2024-06-15T00:00:00.000Z",categories:"rust",authors:["jasa"]},unlisted:!1,nextItem:{title:"Analyzing Linux memory images with volatility",permalink:"/blog/2022/04/04/centos7-volatility"}},l={authorsImageUrls:[void 0]},c=[{value:"The idea",id:"the-idea",level:2},{value:"The test case",id:"the-test-case",level:2},{value:"Loop approach",id:"loop-approach",level:3},{value:"Iterator approach",id:"iterator-approach",level:3},{value:"Common code",id:"common-code",level:3},{value:"Benchmarking code",id:"benchmarking-code",level:3},{value:"Benchmarking results",id:"benchmarking-results",level:2},{value:"Iterators on steroids",id:"iterators-on-steroids",level:2},{value:"Benchmarking parallel iterators",id:"benchmarking-parallel-iterators",level:3},{value:"Iterators as design pattern",id:"iterators-as-design-pattern",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"One more thing",id:"one-more-thing",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Since some time, I'm wondering whether using iterators in Rust has some\nbenefits over traditional ",(0,s.jsx)(n.code,{children:"for"})," loops."]}),"\n",(0,s.jsx)(n.h2,{id:"the-idea",children:"The idea"}),"\n",(0,s.jsx)(n.p,{children:"Consider the following loop:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mut sum = 0;\nfor i in 1..=100 {\n    sum += i;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"which expands during execution to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let mut sum = 0;\nsum += 1;\nsum += 2;\nsum += 3;\n// ...\n"})}),"\n",(0,s.jsx)(n.p,{children:"The way we expressed the sum also defines in which order the summation\nhas to be done. But, to be honest, we are not interested in the concrete order.\nIn fact, the single summations could be done on multiple cores simultaneously."}),"\n",(0,s.jsx)(n.p,{children:"An alternative way of implementing the above algorithm using iterators could be"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let sum: u32 = (1..=100).sum();\n"})}),"\n",(0,s.jsx)(n.p,{children:"Can this be faster? I don't know. So, let's use a more complicated example and check it out"}),"\n",(0,s.jsx)(n.h2,{id:"the-test-case",children:"The test case"}),"\n",(0,s.jsxs)(n.p,{children:["To test which approach is faster, we need to prevent the compiler to optimize too simple things. For example, the above code using the ",(0,s.jsx)(n.code,{children:"for"})," loop compiles to"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-asm",children:"    xor     eax, eax\n    mov     ecx, 100\n    xor     edx, edx\n.LBB45_1:\n    mov     esi, edx\n    lea     edx, [rsi, +, 1]\n    cmp     esi, 100\n    cmovae  edx, ecx\n    add     eax, esi\n    cmp     esi, 99\n    ja      .LBB45_3\n    cmp     edx, 101\n    jb      .LBB45_1\n.LBB45_3:\n    ret\n"})}),"\n",(0,s.jsx)(n.p,{children:"while the iterator based approach compiles to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-asm",children:"    mov     eax, 5050\n    ret\n"})}),"\n",(0,s.jsx)(n.p,{children:"Of course, this results from the fact that the compiler knows a lot about the code to be optimized. So, again, we need a more complicated code."}),"\n",(0,s.jsx)(n.p,{children:"We'll do the following:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["iterate through the first ",(0,s.jsx)(n.code,{children:"1_000_000"})," integers, stored as ",(0,s.jsx)(n.code,{children:"String"})]}),"\n",(0,s.jsxs)(n.li,{children:["convert the ",(0,s.jsx)(n.code,{children:"String"})," into ",(0,s.jsx)(n.code,{children:"u64"})]}),"\n",(0,s.jsxs)(n.li,{children:["filter out numbers which are greater or equal to ",(0,s.jsx)(n.code,{children:"100_000"})]}),"\n",(0,s.jsx)(n.li,{children:"filter out numbers which are no prime numbers"}),"\n",(0,s.jsx)(n.li,{children:"calculate the sum of those numbers"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"We use the following implementations:"}),"\n",(0,s.jsx)(n.h3,{id:"loop-approach",children:"Loop approach"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[inline(never)]\nfn sum1<'s>(data: impl Iterator<Item = &'s String>) -> u64 {\n    let mut s = 0;\n    for i in data {\n        if let Ok(i) = i.parse::<u64>() {\n            if i < 100_000 {\n                if i.is_prime() {\n                    s += i;\n                }\n            }\n        }\n    }\n    s\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"iterator-approach",children:"Iterator approach"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[inline(never)]\nfn sum2<'s>(data: impl Iterator<Item = &'s String>) -> u64 {\n    data.filter_map(|s| s.parse::<u64>().ok())\n        .filter(|i| i < &100_000)\n        .filter(|i| i.is_prime())\n        .sum()\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"common-code",children:"Common code"}),"\n",(0,s.jsxs)(n.p,{children:["To implement the ",(0,s.jsx)(n.code,{children:"is_prime"})," method, I use the following simple code, which is using the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/primes",children:"primes"})," crate:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"trait IsPrime {\n    fn is_prime(&self) -> bool;\n}\n\nimpl IsPrime for u64 {\n    fn is_prime(&self) -> bool {\n        primes::is_prime(*self)\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In addition, I generate a static data array ",(0,s.jsx)(n.code,{children:"NUMBERS"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'lazy_static! {\n    static ref NUMBERS: Vec<String> = (1..1_000_000).map(|i| format!("{i}")).collect();\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-code",children:"Benchmarking code"}),"\n",(0,s.jsxs)(n.p,{children:["To test the speed of the above code, I'm using ",(0,s.jsx)(n.code,{children:"cargo bench"})," with the following test code"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use test::Bencher;\n\n    #[bench]\n    fn test_sum1(b: &mut Bencher) {\n        b.iter(|| assert_eq!(sum1(NUMBERS.iter()), 454396537))\n    }\n\n    #[bench]\n    fn test_sum2(b: &mut Bencher) {\n        b.iter(|| assert_eq!(sum2(NUMBERS.iter()), 454396537))\n    }\n}\n\n"})}),"\n",(0,s.jsx)(n.h2,{id:"benchmarking-results",children:"Benchmarking results"}),"\n",(0,s.jsx)(n.p,{children:"Running the benchmark yields the following result:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"test tests::test_sum1 ... bench:  25,637,873.10 ns/iter (+/- 1,921,695.73)\ntest tests::test_sum2 ... bench:  25,639,836.30 ns/iter (+/- 1,405,975.61)\n"})}),"\n",(0,s.jsx)(n.p,{children:"OMG, what has happened???!!? Both approaches are equally performant. There seems to be no important difference between using a loop or iterator."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"That's our first result: It doesn't matter whether you use traditional loops or iterators. You can expect both to be similar fast."})}),"\n",(0,s.jsx)(n.h2,{id:"iterators-on-steroids",children:"Iterators on steroids"}),"\n",(0,s.jsxs)(n.p,{children:["Let's change out iterator based sum function a little bit: replacing ",(0,s.jsx)(n.code,{children:"Iterator"})," by ",(0,s.jsx)(n.code,{children:"ParallelIterator"}),", which is a trait from the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/rayon",children:"rayon"})," crate. ",(0,s.jsx)(n.em,{children:"rayon"})," allows you to do anything in parallel what you can do with normal iterators. So, if you have some code which is based on using iterators, you can simply switch to parallel iterators."]}),"\n",(0,s.jsx)(n.p,{children:"We add an additional sum function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"\n#[inline(never)]\nfn sum3<'s>(data: impl ParallelIterator<Item = &'s String>) -> u64 {\n    data.filter_map(|s| s.parse::<u64>().ok())\n        .filter(|i| i < &100_000)\n        .filter(|i| i.is_prime())\n        .sum()\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Be aware that the only difference to ",(0,s.jsx)(n.code,{children:"sum2"})," is the trait ",(0,s.jsx)(n.code,{children:"ParallelIterator"}),". No other code change is necessary."]}),"\n",(0,s.jsx)(n.p,{children:"Also, we need a benchmarking function:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[bench]\nfn test_sum3(b: &mut Bencher) {\n    b.iter(|| assert_eq!(sum3(NUMBERS.par_iter()), 454396537))\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see, there is another difference: to create a ",(0,s.jsx)(n.code,{children:"ParallelIterator"}),", we use the function ",(0,s.jsx)(n.code,{children:"par_iter()"})," instead of ",(0,s.jsx)(n.code,{children:"iter()"}),". So, you have the full control whether you want to use parallel iterators or not."]}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-parallel-iterators",children:"Benchmarking parallel iterators"}),"\n",(0,s.jsx)(n.p,{children:"The benchmarking result (on a system with 4 virtual CPUs) is very informative:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"test tests::test_sum1 ... bench:  25,621,303.60 ns/iter (+/- 1,528,567.84)\ntest tests::test_sum2 ... bench:  25,752,965.60 ns/iter (+/- 2,927,367.52)\ntest tests::test_sum3 ... bench:  11,761,348.20 ns/iter (+/- 2,472,399.91)\n"})}),"\n",(0,s.jsx)(n.p,{children:"We can conclude:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"using the parallel iterator in our test case is significantly faster"}),"\n",(0,s.jsx)(n.li,{children:"migrating the code from traditional iterators to parallel iterators is simple"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"iterators-as-design-pattern",children:"Iterators as design pattern"}),"\n",(0,s.jsxs)(n.p,{children:["Using iterators is an implementation of the ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Pipeline_(software)",children:"Pipes-and-Filters"})," design pattern:"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(3487).Z+"",children:(0,s.jsx)(n.img,{src:t(5220).Z+""})})}),"\n",(0,s.jsx)(n.p,{children:"This approach has a lot of practical benefits:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["it is easy to","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["insert a ",(0,s.jsx)(n.em,{children:"processor"})," into the pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:["remove one ",(0,s.jsx)(n.em,{children:"processor"})," from the pipeline"]}),"\n",(0,s.jsxs)(n.li,{children:["change the order of ",(0,s.jsx)(n.em,{children:"processors"})," in the pipeline"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["every single ",(0,s.jsx)(n.em,{children:"processor"})," is independant of the other, which allows to distribute them over multiple cores or even machines"]}),"\n",(0,s.jsx)(n.li,{children:"it can be easier to read (if you're familiar with the concept)"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"It doesn't matter if you use traditional loops or iterators. There will be no significant performance impact. But, if you want to be able to do significant changes, such as distributing loop iterations over multiple CPUs, without breaking your code, use iterators."}),"\n",(0,s.jsx)(n.h2,{id:"one-more-thing",children:"One more thing"}),"\n",(0,s.jsx)(n.p,{children:"It is very important to implement you algorithm in the right way. But it is more important to understand the algorithm in detail, and to keep your implementation as neat to that as possible."}),"\n",(0,s.jsxs)(n.p,{children:["For example, let's change ",(0,s.jsx)(n.code,{children:"sum1"})," by inserting a ",(0,s.jsx)(n.code,{children:"break"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"\n#[inline(never)]\nfn sum1<'s>(data: impl Iterator<Item = &'s String>) -> u64 {\n    let mut s = 0;\n    for i in data {\n        if let Ok(i) = i.parse::<u64>() {\n            if i >= 100_000 {\n                break;\n            }\n            if i.is_prime() {\n                s += i;\n            }\n        }\n    }\n    s\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"and again benchmarking:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"test tests::test_sum1 ... bench:  11,603,891.70 ns/iter (+/- 742,577.75)\ntest tests::test_sum2 ... bench:  25,899,039.20 ns/iter (+/- 1,916,178.50)\ntest tests::test_sum3 ... bench:  11,899,570.60 ns/iter (+/- 5,477,771.27)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["What has happened? Clearly, it doesn't make sense to iterate through ",(0,s.jsx)(n.code,{children:"1_000_000"})," numbers, while we're only interested in the first ",(0,s.jsx)(n.code,{children:"100_000"}),". Because when using a loop we know the order of the execution, we can abort as soon as we crossed the border to uninteresting numbers (those above ",(0,s.jsx)(n.code,{children:"100_000"}),"). In our test case, this has a similar effect to the performance such as using parallel iterators."]}),"\n",(0,s.jsx)(n.p,{children:"So, again: First you need to completely understand your problem, choose the best matching algorithm, and implement it correctly. Then, you can optimize."})]})}function d(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},3487:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/files/iterator-pipes-filter.drawio-d10bfc536da495a3905ede32a64ede17.svg"},5220:(e,n,t)=>{t.d(n,{Z:()=>s});const s=t.p+"assets/images/iterator-pipes-filter.drawio-d10bfc536da495a3905ede32a64ede17.svg"},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var s=t(7294);const r={},i=s.createContext(r);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);